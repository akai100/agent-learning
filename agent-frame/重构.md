## ä¸€ã€åŸç‰ˆ MVP çš„é—®é¢˜ï¼ˆä½ å¿…é¡»èƒ½çœ‹å‡ºæ¥ï¼‰

åŸå§‹ç‰ˆæœ¬èƒ½è·‘ï¼Œä½†æœ‰ 5 ä¸ªå·¥ç¨‹éšæ‚£ï¼š

**âŒ 1. Agentã€Promptã€Parserã€Executor æ··åœ¨ä¸€èµ·**

+ ```agent.step()``` æ—¢åœ¨ï¼š
  + è°ƒæ¨¡å‹
  + è§£æ Action
  + è°ƒå·¥å…·
  + æ§åˆ¶å¾ªç¯

**ğŸ‘‰ ä¸å¯ç»´æŠ¤**

**âŒ 2. ReAct æ˜¯â€œé  Prompt çº¦å®šâ€ï¼Œä¸æ˜¯â€œé ç»“æ„ä¿è¯â€**

+ æ¨¡å‹ä¸€æ—¦è¾“å‡ºæ ¼å¼é”™

+ ç³»ç»Ÿç›´æ¥å´©

**ğŸ‘‰ æ²¡æœ‰é˜²å¾¡å±‚**

**âŒ 3. Observation ç”¨ user role æ³¨å…¥ï¼ˆå±é™©ï¼‰**

+ å®¹æ˜“è¢« Prompt Injection åˆ©ç”¨

+ è¯­ä¹‰ä¸æ¸…æ™°

**âŒ 4. æ²¡æœ‰â€œç»“æŸåˆ¤æ–­é€»è¾‘â€**

+ åªæ˜¯çœ‹åˆ° ```Action: NONE``` å°±ç»“æŸ

+ æ— æ³•æ‰©å±•ï¼ˆå¦‚ max_steps / timeoutï¼‰

**âŒ 5. Agent æ²¡æœ‰â€œèŒè´£è¾¹ç•Œâ€**

Agent åº”è¯¥åªåšä¸€ä»¶äº‹ï¼š

**æ§åˆ¶ Loopï¼Œè€Œä¸æ˜¯å¹²æ‰€æœ‰æ´»**

## äºŒã€é‡æ„ç›®æ ‡ï¼ˆéå¸¸é‡è¦ï¼‰

è¿™æ¬¡é‡æ„æˆ‘ä»¬éµå¾ª 5 æ¡åŸåˆ™ï¼š

1. å•ä¸€èŒè´£

2. ReAct ç»“æ„æ˜¾å¼åŒ–ï¼ˆä¸æ˜¯é  Prompt çŒœï¼‰

3. Action / Observation æ˜¯â€œç³»ç»Ÿæ¶ˆæ¯â€ï¼Œä¸æ˜¯ç”¨æˆ·

4. Agent Loop å¯æ§ï¼ˆstep / max_stepsï¼‰

5. æœªæ¥èƒ½è‡ªç„¶æ‰©å±•åˆ° Tool Router / Memory

## ä¸‰ã€é‡æ„åçš„ç»“æ„ï¼ˆæ¨èä½ é•¿æœŸç”¨ï¼‰

```
clean_agent/
â”œâ”€â”€ agent.py        # Agent loopï¼ˆåªç®¡æµç¨‹ï¼‰
â”œâ”€â”€ llm.py          # LLM æŠ½è±¡
â”œâ”€â”€ tools.py        # å·¥å…·ç³»ç»Ÿ
â”œâ”€â”€ parser.py       # ReAct è¾“å‡ºè§£æ
â”œâ”€â”€ prompt.py       # System Prompt
â””â”€â”€ run.py          # å…¥å£
```

## å››ã€é‡æ„åçš„æ ¸å¿ƒä»£ç ï¼ˆå¹²å‡€ç‰ˆï¼‰

### 1ï¸âƒ£ System Promptï¼ˆæ›´ä¸¥æ ¼ï¼‰

```prompt.py```

```python3
SYSTEM_PROMPT = """
You are a ReAct-style AI Agent.

You must respond using the following format ONLY:

Thought: <your reasoning>
Action: <tool_name>: <tool_input> | NONE

Rules:
- Use tools ONLY if necessary.
- If Action is NONE, you are done.
- Do NOT fabricate observations.
- Be concise and deterministic.

Available tools:
- calculator: evaluate a math expression
"""
```

### 2ï¸âƒ£ å·¥å…·ç³»ç»Ÿï¼ˆä¸å˜ï¼Œä½†èŒè´£æ¸…æ™°ï¼‰

```tools.py```

```python3
class ToolRegistry:
    def __init__(self):
        self.tools = {}

    def register(self, name, func):
        self.tools[name] = func

    def execute(self, name, arg):
        if name not in self.tools:
            return f"Error: unknown tool '{name}'"
        try:
            return self.tools[name](arg)
        except Exception as e:
            return f"Tool error: {e}"


def calculator(expression: str) -> str:
    return str(eval(expression))
```

### 3ï¸âƒ£ ReAct è§£æå™¨ï¼ˆå…³é”®é‡æ„ç‚¹ï¼‰

```parser.py```

```python3
import re
from dataclasses import dataclass
from typing import Optional

@dataclass
class AgentAction:
    tool: Optional[str]
    input: Optional[str]
    is_done: bool


class ReActParser:
    ACTION_RE = re.compile(r"Action:\s*(.*)")

    def parse(self, text: str) -> AgentAction:
        match = self.ACTION_RE.search(text)
        if not match:
            raise ValueError("No Action found in model output")

        action = match.group(1).strip()

        if action == "NONE":
            return AgentAction(None, None, True)

        if ":" not in action:
            raise ValueError(f"Invalid Action format: {action}")

        tool, arg = action.split(":", 1)
        return AgentAction(tool.strip(), arg.strip(), False)
````

ğŸ‘‰ é‡è¦å˜åŒ–

Action å˜æˆ ç»“æ„åŒ–å¯¹è±¡

é”™è¯¯ç›´æ¥æš´éœ²ï¼ˆä¾¿äº Debugï¼‰

### 4ï¸âƒ£ LLM æŠ½è±¡ï¼ˆä¸ºä»¥åæ¢æ¨¡å‹åšå‡†å¤‡ï¼‰

```llm.py```

```python3
import openai

class OpenAILLM:
    def __init__(self, model="gpt-4o-mini", temperature=0):
        self.model = model
        self.temperature = temperature

    def call(self, messages):
        resp = openai.ChatCompletion.create(
            model=self.model,
            messages=messages,
            temperature=self.temperature
        )
        return resp["choices"][0]["message"]["content"]

5ï¸âƒ£ Agent æœ¬ä½“ï¼ˆç°åœ¨éå¸¸å¹²å‡€ï¼‰
agent.py
from parser import ReActParser

class Agent:
    def __init__(self, llm, tools, system_prompt, max_steps=5):
        self.llm = llm
        self.tools = tools
        self.parser = ReActParser()
        self.max_steps = max_steps

        self.messages = [
            {"role": "system", "content": system_prompt}
        ]

    def run(self, task: str):
        self.messages.append({"role": "user", "content": task})

        for step in range(self.max_steps):
            print(f"\n=== Step {step + 1} ===")

            output = self.llm.call(self.messages)
            print(output)

            self.messages.append({"role": "assistant", "content": output})

            action = self.parser.parse(output)

            if action.is_done:
                print("\nâœ… Agent finished")
                return

            observation = self.tools.execute(action.tool, action.input)
            obs_message = f"Observation: {observation}"

            print(obs_message)

            # Observation æ˜¯ system-level feedback
            self.messages.append(
                {"role": "system", "content": obs_message}
            )

        print("\nâ›” Max steps reached")


ğŸ‘‰ æ³¨æ„è¿™å‡ ç‚¹å˜åŒ–

Agent åªç®¡æµç¨‹

æ²¡æœ‰ Prompt / Tool / Parser ç»†èŠ‚

Loop æ˜¯æ˜¾å¼ã€å¯æ§çš„

6ï¸âƒ£ å¯åŠ¨å…¥å£
run.py
from agent import Agent
from llm import OpenAILLM
from tools import ToolRegistry, calculator
from prompt import SYSTEM_PROMPT
import openai

openai.api_key = "YOUR_API_KEY"

tools = ToolRegistry()
tools.register("calculator", calculator)

llm = OpenAILLM()
agent = Agent(llm, tools, SYSTEM_PROMPT)

agent.run("What is (12 * 7) + 5?")

äº”ã€è¿™æ¬¡é‡æ„ä½ çœŸæ­£å­¦åˆ°çš„ 5 ä»¶äº‹

å¦‚æœä½ ç†è§£äº†ä¸‹é¢è¿™ 5 æ¡ï¼Œè¯´æ˜ä½ å·²ç»å¼€å§‹åƒ Agent å·¥ç¨‹å¸ˆ æ€è€ƒäº†ï¼š

Agent â‰  Prompt

ReAct æ˜¯ åè®® + è§£æ + æ‰§è¡Œ

LLM æ˜¯å¯æ›¿æ¢ç»„ä»¶

Observation æ˜¯ç³»ç»Ÿåé¦ˆï¼Œä¸æ˜¯â€œç”¨æˆ·è¾“å…¥â€

Agent Loop å¿…é¡»å¯æ§ã€å¯ç»ˆæ­¢

å…­ã€å¼ºçƒˆå»ºè®®ä½ ç°åœ¨åšçš„ 3 ä¸ªç»ƒä¹ 

ä¸è¦è·³è¿‡ ğŸ‘‡

â— æ•…æ„è®©æ¨¡å‹è¾“å‡ºä¸å« Actionï¼Œçœ‹ç³»ç»Ÿæ€ä¹ˆæŠ¥é”™

â— æŠŠ max_steps è®¾ä¸º 1ï¼Œçœ‹ Agent å¦‚ä½•å¤±è´¥

â— æ–°åŠ ä¸€ä¸ªå‡å·¥å…· search_stubï¼Œä¸æ”¹ Agent ä»£ç 
