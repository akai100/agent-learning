
它是一种让大语言模型将 **“推理（Reasoning）” 与 “行动（Action）” 相结合**的提示词框架，核心是引导模型像人类一样 “先思考该做什么→再执行具体行动→根据行动反馈调整思考”，形成闭环迭代，最终解决复杂任务。

## 1. 核心定义与本质

**1. 核心定义**

ReAct（Reasoning + Acting）是一种大语言模型提示范式，它强制模型输出 **“思考（Thought）- 行动（Action）- 观察（Observation）”** 的循环流程：

+ Thought

  分析当前任务状态、已知信息，明确下一步该做什么、为什么要这么做（对应 “推理” 环节）

+ Action

  执行具体的可落地行动（如调用工具、查询数据、编写代码、拆解子任务等，对应 “行动” 环节）

+ Observation

  获取行动执行后的反馈结果（如工具返回数据、代码运行结果、查询到的信息等）

通过多轮这种循环，模型逐步逼近任务目标，最终得出结果。

**2. 本质**

ReAct 的本质是 **还原人类解决复杂问题的自然流程**—— 人类面对未知任务时，不会直接凭空推导答案，而是先思考 “需要什么信息 / 工具”，再通过行动获取信息，最后根据反馈调整思路，反复迭代直至完成任务。

ReAct 就是将这种人类流程固化为模型的输出格式，激活模型的 “推理 - 行动” 关联能力，同时通过 “观察” 反馈解决模型的信息局限性（如实时数据缺失、私有知识未知等）。

**3. 与 CoT 的核心区别

| 对比维度 | CoT                | ReAct                                            |
| -------  | ----               | ----                                             |
| 核心逻辑  | 纯内部推理，无外部行动|推理（Thought）+ 行动（Action）+ 反馈（Observation）|
| 信息来源  | 	依赖模型自身训练数据 | 模型训练数据 + 外部环境反馈（工具、查询等） |
| 任务适配 | 封闭性任务（无需外部信息） | 开放性任务（需要外部信息 / 工具交互） |
| 流程形式 | 单轮推理链（一步到位输出所有步骤） | 多轮闭环迭代（每轮根据反馈调整思路） |
| 典型示例 | 数学计算、逻辑推导（无需查资料） | 实时信息查询、工具调用、代码调试、知识库检索 |

## 2. ReAct 的核心流程（标准闭环）

**单轮核心循环（基础单元）**

1. Thought 阶段（推理）

+ 输入：任务目标 + 历史循环的 “Thought-Action-Observation” 记录 + 当前已知信息

+ 输出：明确的推理结论，包括：

   + 当前已掌握的信息和待解决的问题。
 
   + 下一步行动的目的和逻辑依据。
 
   + 排除不合理的行动选项

示例：“当前任务是计算 100 以内质数的和，我已经编写并验证了质数判断函数（is_prime），下一步需要遍历 2-100 的数字，用该函数筛选质数并求和，这样才能得到最终结果。”

**2. Action 阶段（行动）**

+ 输入：上一步 Thought 明确的行动指令。

+ 输出：具体、可执行、可验证的行动内容，常见行动类型包括：

  + 工具调用：调用搜索引擎、计算器、数据库、API 等外部工具。
  
  + 代码执行：编写 / 运行代码完成计算、数据处理等任务。

  + 信息拆解：将复杂任务拆分为更小的子任务。

  + 内容生成：生成符合要求的文本、表格等中间产物。

示例：编写代码遍历 2-100 的数字，筛选质数并求和（对应代码行动）；调用搜索引擎查询 “2024 诺贝尔物理学奖”（对应工具调用行动）。

**3. Observation 阶段（反馈）**

+ 输入：上一步 Action 的执行结果。

+ 输出：客观、真实的反馈信息，无主观推理，仅陈述事实：

  + 若行动是代码执行：反馈代码运行结果（正确输出 / 错误日志）。
  
  + 若行动是工具调用：反馈工具返回的原始数据。

  + 若行动是信息拆解：反馈拆解后的子任务列表。

示例：“代码运行结果：100 以内质数列表为 [2,3,5,...,97]，总和为 1060”；“搜索引擎返回：2024 年诺贝尔物理学奖得主为 XX 和 XX，研究成果是 XX”。

**多轮迭代（完整任务流程）**

对于复杂任务，单轮循环无法完成目标，需要多轮迭代：

1. 初始轮：输入原始任务，模型输出第一轮 Thought → 执行 Action → 获取 Observation。

2. 后续轮：将上一轮的 “Thought-Action-Observation” 加入上下文，模型基于反馈更新思考，输出新一轮 Thought → Action → Observation。

3. 终止轮：当 Observation 反馈的信息满足任务目标时，模型停止迭代，输出最终结论。


## 3. ReAct 的核心优势

1. **解决模型信息局限性**

   通过外部行动（工具调用、查询）获取实时信息、私有知识、冷门数据，避免因训练数据过时 / 不全导致的幻觉。

2. **提升任务可验证性**

   行动步骤和反馈结果可追溯、可复现，若任务出错，可快速定位是 “思考逻辑错误” 还是 “行动执行错误”。

3. **适配复杂开放性任务**

   能处理 CoT 无法应对的任务（如实时信息查询、工具调用、多步骤代码调试、私有知识库检索等）。
   
4. **降低推理偏差**

   每一轮的反馈信息会修正模型的推理方向，避免 “一步错、步步错” 的连锁偏差，提升最终结果的准确性。

5. **无需额外训练**

   作为提示词框架，无需微调模型，仅通过定义输出格式即可生效，适配所有大语言模型。

## 4. 主要类型与典型应用场景

**1. 主要类型**

根据行动对象的不同，ReAct 可分为两类核心类型：

+ 内部行动 ReAct

  行动无需依赖外部工具，仅在模型内部完成（如编写代码、拆解子任务、生成中间文本），适用于封闭性复杂任务（如质数求和、代码调试）。

+ 外部行动 ReAct

  行动需要依赖外部工具 / 环境（如搜索引擎、计算器、数据库、API、机器人等），适用于开放性任务（如实时信息查询、业务数据统计、智能设备控制）。

**2. 高适配应用场景**

+ 实时信息查询

  如 “最新的行业数据”“近期重大新闻”“诺贝尔奖项得主”“股票实时价格” 等，模型通过调用搜索引擎获取实时数据。

+ 工具调用

  如 “用计算器计算 768×8/3 的向上取整结果”“调用翻译 API 将英文论文译为中文”“调用数据库查询用户信息” 等。

+ 代码开发与调试

  如 “分步编写 GLU 前馈网络代码，先验证质数判断函数，再筛选求和”“调试一段报错的 Python 代码，先分析错误日志，再修改代码”。

+ 复杂任务拆解与执行

  如 “制定一份大模型学习计划，先拆解为基础阶段、进阶阶段，再明确每个阶段的学习内容”“规划一次旅行，先查询目的地天气，再预订酒店，最后整理行程”。

+ 私有 / 冷门知识检索

  如 “从公司内部知识库中查询 XX 项目的技术文档”“查询某小众学术论文的核心观点” 等。

**3. 非适配场景**

+ 简单直接任务

  无需推理和行动的任务（如 “提取文本主语”“润色一句话”），直接输出即可，使用 ReAct 会增加冗余。

+ 无外部反馈的任务

  无法获取行动反馈的任务（如无工具支持的超小众知识查询），ReAct 无法形成闭环迭代。

## 4. 关键技巧

**1. 明确格式约束**

在提示词中严格定义 “Thought-Action-Observation” 的输出格式，禁止模型跳过某一环节，确保流程规范。

+ 示例提示：“请严格按照以下格式输出：1. Thought：分析当前任务和下一步行动；2. Action：执行具体行动；3. Observation：仅陈述行动反馈结果。”

**2. 细化 Thought 逻辑**

引导模型在 Thought 中明确 “当前已知信息”“待解决问题”“行动依据”，避免模糊的思考表述。

**3. 确保 Action 可执行**

Action 必须具体、落地，避免抽象表述（如 “查询数据” 改为 “调用搜索引擎查询 2024 诺贝尔物理学奖得主”；“写代码” 改为 “编写质数筛选与求和的 Python 代码”）。

**4. 重视 Observation 客观性**

Observation 仅陈述行动反馈的事实，不加入主观推理，确保模型基于真实反馈调整思考。

**5. 控制循环次数**

为复杂任务设置合理的循环上限，避免无限迭代，同时在每一轮判断是否已满足任务目标。

**6. 结合 CoT 优势**

在 ReAct 的 Thought 阶段融入 CoT 的分步推理逻辑，让模型的思考更细致，进一步提升行动的准确性。
